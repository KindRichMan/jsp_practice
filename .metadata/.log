!SESSION 2022-02-16 09:06:34.516 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file C:\eclipse\workspace2\.metadata\.bak_0.log
Created Time: 2022-02-16 09:07:14.831
!SESSION 2022-02-16 09:06:34.516 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-02-16 09:07:14.832
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-16 09:07:14.832
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@59301546,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@25fc2b8f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-16 09:07:19.706
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-16 09:07:19.707
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-16 09:07:19.744
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.wst.xml.core 4 4 2022-02-16 11:26:47.785
!MESSAGE IStructuredDocumentRegion management failed.
!STACK 0
org.eclipse.wst.xml.core.internal.document.StructuredDocumentRegionManagementException: IStructuredDocumentRegion management failed.
	at org.eclipse.wst.xml.core.internal.document.XMLModelParser.removeStructuredDocumentRegion(XMLModelParser.java:2267)
	at org.eclipse.wst.xml.core.internal.document.XMLModelParser.replaceStructuredDocumentRegions(XMLModelParser.java:2341)
	at org.eclipse.wst.xml.core.internal.document.DOMModelImpl.nodesReplaced(DOMModelImpl.java:742)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument._fireEvent(BasicStructuredDocument.java:602)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.fireStructuredDocumentEvent(BasicStructuredDocument.java:1200)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.internalReplaceText(BasicStructuredDocument.java:1981)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.replaceText(BasicStructuredDocument.java:2425)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.replaceText(BasicStructuredDocument.java:2410)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.access$2(JobSafeStructuredDocument.java:1)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument$3.run(JobSafeStructuredDocument.java:143)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.wst.sse.ui.EditorExecutionContext.execute(EditorExecutionContext.java:150)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.replaceText(JobSafeStructuredDocument.java:146)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.replace(BasicStructuredDocument.java:2370)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.access$0(JobSafeStructuredDocument.java:1)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument$1.run(JobSafeStructuredDocument.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.wst.sse.ui.EditorExecutionContext.execute(EditorExecutionContext.java:150)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.replace(JobSafeStructuredDocument.java:108)
	at org.eclipse.jface.text.projection.ProjectionTextStore.replace(ProjectionTextStore.java:106)
	at org.eclipse.jface.text.AbstractDocument.replace(AbstractDocument.java:1093)
	at org.eclipse.jface.text.AbstractDocument.replace(AbstractDocument.java:1118)
	at org.eclipse.jface.text.projection.ProjectionDocument.replace(ProjectionDocument.java:627)
	at org.eclipse.jface.text.DefaultDocumentAdapter.replaceTextRange(DefaultDocumentAdapter.java:223)
	at org.eclipse.swt.custom.StyledText.modifyContent(StyledText.java:7601)
	at org.eclipse.swt.custom.StyledText.sendKeyEvent(StyledText.java:8501)
	at org.eclipse.swt.custom.StyledText.doContent(StyledText.java:2540)
	at org.eclipse.swt.custom.StyledText.handleKey(StyledText.java:6222)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6253)
	at org.eclipse.swt.custom.StyledText.lambda$28(StyledText.java:5932)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4958)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2022-02-16 15:42:30.077 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-02-16 15:42:35.581
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-16 15:42:35.581
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@37f0fb02,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4687fee7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-16 15:42:39.506
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-16 15:42:39.507
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-16 15:42:39.555
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-16 15:45:56.508 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-02-16 15:46:03.685
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-16 15:46:03.685
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4687fee7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a0fc665,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-16 15:46:07.306
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-16 15:46:07.307
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-16 15:46:07.340
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.wst.xml.core 4 4 2022-02-16 20:02:31.785
!MESSAGE IStructuredDocumentRegion management failed.
!STACK 0
org.eclipse.wst.xml.core.internal.document.StructuredDocumentRegionManagementException: IStructuredDocumentRegion management failed.
	at org.eclipse.wst.xml.core.internal.document.XMLModelParser.removeStructuredDocumentRegion(XMLModelParser.java:2224)
	at org.eclipse.wst.xml.core.internal.document.XMLModelParser.changeStructuredDocumentRegion(XMLModelParser.java:548)
	at org.eclipse.wst.xml.core.internal.document.XMLModelParser.changeData(XMLModelParser.java:238)
	at org.eclipse.wst.xml.core.internal.document.XMLModelParser.changeRegion(XMLModelParser.java:321)
	at org.eclipse.wst.xml.core.internal.document.DOMModelImpl.regionChanged(DOMModelImpl.java:801)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument._fireEvent(BasicStructuredDocument.java:544)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.fireStructuredDocumentEvent(BasicStructuredDocument.java:1182)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.internalReplaceText(BasicStructuredDocument.java:1966)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.replaceText(BasicStructuredDocument.java:2425)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.replaceText(BasicStructuredDocument.java:2410)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.access$2(JobSafeStructuredDocument.java:1)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument$3.run(JobSafeStructuredDocument.java:143)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.wst.sse.ui.EditorExecutionContext.execute(EditorExecutionContext.java:150)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.replaceText(JobSafeStructuredDocument.java:146)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.replace(BasicStructuredDocument.java:2370)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.access$0(JobSafeStructuredDocument.java:1)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument$1.run(JobSafeStructuredDocument.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.wst.sse.ui.EditorExecutionContext.execute(EditorExecutionContext.java:150)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.replace(JobSafeStructuredDocument.java:108)
	at org.eclipse.jface.text.projection.ProjectionTextStore.replace(ProjectionTextStore.java:106)
	at org.eclipse.jface.text.AbstractDocument.replace(AbstractDocument.java:1093)
	at org.eclipse.jface.text.AbstractDocument.replace(AbstractDocument.java:1118)
	at org.eclipse.jface.text.projection.ProjectionDocument.replace(ProjectionDocument.java:627)
	at org.eclipse.jface.text.DefaultDocumentAdapter.replaceTextRange(DefaultDocumentAdapter.java:223)
	at org.eclipse.swt.custom.StyledText.modifyContent(StyledText.java:7601)
	at org.eclipse.swt.custom.StyledText.sendKeyEvent(StyledText.java:8501)
	at org.eclipse.swt.custom.StyledText.doContent(StyledText.java:2540)
	at org.eclipse.swt.custom.StyledText.handleKey(StyledText.java:6222)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6253)
	at org.eclipse.swt.custom.StyledText.lambda$28(StyledText.java:5932)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4958)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2022-02-17 09:07:14.521 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-02-17 09:08:13.777
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-17 09:08:13.777
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5de6c7d7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69f55ea,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-17 09:08:18.679
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-17 09:08:18.680
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-17 09:08:18.718
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jst.jee 4 2 2022-02-17 19:26:05.048
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jst.jee".
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.emf.ecore.xmi.impl.XMLResourceImpl.setEncoding(String)" because "res" is null
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.createModelResource(JEE5ModelProvider.java:209)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.getModelResource(JEE5ModelProvider.java:190)
	at org.eclipse.jst.jee.model.internal.Web25ModelProvider.getModelObject(Web25ModelProvider.java:44)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.getModelObject(JEE5ModelProvider.java:233)
	at org.eclipse.jst.jee.model.internal.Web25MergedModelProvider.getXmlWebApp(Web25MergedModelProvider.java:59)
	at org.eclipse.jst.jee.model.internal.Web25MergedModelProvider.internalModelChanged(Web25MergedModelProvider.java:155)
	at org.eclipse.jst.jee.model.internal.Web25MergedModelProvider.xmlModelChanged(Web25MergedModelProvider.java:146)
	at org.eclipse.jst.jee.model.internal.common.AbstractMergedModelProvider$XmlModelListener.modelsChanged(AbstractMergedModelProvider.java:91)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider$NotifyRunner.run(JEE5ModelProvider.java:470)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.notifyListeners(JEE5ModelProvider.java:445)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.resourceChanged(JEE5ModelProvider.java:117)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider$ResourceAdapter.notifyChanged(JEE5ModelProvider.java:81)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.setModified(ResourceImpl.java:1867)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl$ContentsEList.modified(ResourceImpl.java:486)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl$ContentsEList.didRemove(ResourceImpl.java:447)
	at org.eclipse.emf.common.util.AbstractEList.didClear(AbstractEList.java:170)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl$ContentsEList.didClear(ResourceImpl.java:466)
	at org.eclipse.emf.common.util.BasicEList.clear(BasicEList.java:639)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.doClear(NotifyingListImpl.java:1158)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.clear(NotifyingListImpl.java:1085)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.doUnload(ResourceImpl.java:1699)
	at org.eclipse.emf.ecore.xmi.impl.XMLResourceImpl.doUnload(XMLResourceImpl.java:720)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.unload(ResourceImpl.java:1721)
	at org.eclipse.jem.internal.util.emf.workbench.ProjectResourceSetImpl.removeAndUnloadAllResources(ProjectResourceSetImpl.java:885)
	at org.eclipse.jem.internal.util.emf.workbench.ProjectResourceSetImpl.release(ProjectResourceSetImpl.java:866)
	at org.eclipse.wst.common.internal.emfworkbench.integration.ResourceSetWorkbenchEditSynchronizer.release(ResourceSetWorkbenchEditSynchronizer.java:222)
	at org.eclipse.jem.util.emf.workbench.ResourceSetWorkbenchSynchronizer.resourceChanged(ResourceSetWorkbenchSynchronizer.java:184)
	at org.eclipse.wst.common.internal.emfworkbench.integration.ResourceSetWorkbenchEditSynchronizer.resourceChanged(ResourceSetWorkbenchEditSynchronizer.java:137)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.handleEvent(NotificationManager.java:271)
	at org.eclipse.core.internal.resources.Workspace.broadcastEvent(Workspace.java:376)
	at org.eclipse.core.internal.resources.Resource.broadcastPreMoveEvent(Resource.java:1878)
	at org.eclipse.core.internal.resources.Resource.move(Resource.java:1493)
	at org.eclipse.ltk.core.refactoring.resource.RenameResourceChange.perform(RenameResourceChange.java:118)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:281)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.lambda$0(PerformChangeOperation.java:258)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2313)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2338)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:295)
	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.executeChange(UIPerformChangeOperation.java:94)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:219)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2313)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2338)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:89)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.jst.jee 4 0 2022-02-17 19:26:05.050
!MESSAGE Cannot invoke "org.eclipse.emf.ecore.xmi.impl.XMLResourceImpl.setEncoding(String)" because "res" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.emf.ecore.xmi.impl.XMLResourceImpl.setEncoding(String)" because "res" is null
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.createModelResource(JEE5ModelProvider.java:209)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.getModelResource(JEE5ModelProvider.java:190)
	at org.eclipse.jst.jee.model.internal.Web25ModelProvider.getModelObject(Web25ModelProvider.java:44)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.getModelObject(JEE5ModelProvider.java:233)
	at org.eclipse.jst.jee.model.internal.Web25MergedModelProvider.getXmlWebApp(Web25MergedModelProvider.java:59)
	at org.eclipse.jst.jee.model.internal.Web25MergedModelProvider.internalModelChanged(Web25MergedModelProvider.java:155)
	at org.eclipse.jst.jee.model.internal.Web25MergedModelProvider.xmlModelChanged(Web25MergedModelProvider.java:146)
	at org.eclipse.jst.jee.model.internal.common.AbstractMergedModelProvider$XmlModelListener.modelsChanged(AbstractMergedModelProvider.java:91)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider$NotifyRunner.run(JEE5ModelProvider.java:470)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.notifyListeners(JEE5ModelProvider.java:445)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.resourceChanged(JEE5ModelProvider.java:117)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider$ResourceAdapter.notifyChanged(JEE5ModelProvider.java:81)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.setModified(ResourceImpl.java:1867)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl$ContentsEList.modified(ResourceImpl.java:486)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl$ContentsEList.didRemove(ResourceImpl.java:447)
	at org.eclipse.emf.common.util.AbstractEList.didClear(AbstractEList.java:170)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl$ContentsEList.didClear(ResourceImpl.java:466)
	at org.eclipse.emf.common.util.BasicEList.clear(BasicEList.java:639)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.doClear(NotifyingListImpl.java:1158)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.clear(NotifyingListImpl.java:1085)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.doUnload(ResourceImpl.java:1699)
	at org.eclipse.emf.ecore.xmi.impl.XMLResourceImpl.doUnload(XMLResourceImpl.java:720)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.unload(ResourceImpl.java:1721)
	at org.eclipse.jem.internal.util.emf.workbench.ProjectResourceSetImpl.removeAndUnloadAllResources(ProjectResourceSetImpl.java:885)
	at org.eclipse.jem.internal.util.emf.workbench.ProjectResourceSetImpl.release(ProjectResourceSetImpl.java:866)
	at org.eclipse.wst.common.internal.emfworkbench.integration.ResourceSetWorkbenchEditSynchronizer.release(ResourceSetWorkbenchEditSynchronizer.java:222)
	at org.eclipse.jem.util.emf.workbench.ResourceSetWorkbenchSynchronizer.resourceChanged(ResourceSetWorkbenchSynchronizer.java:184)
	at org.eclipse.wst.common.internal.emfworkbench.integration.ResourceSetWorkbenchEditSynchronizer.resourceChanged(ResourceSetWorkbenchEditSynchronizer.java:137)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.handleEvent(NotificationManager.java:271)
	at org.eclipse.core.internal.resources.Workspace.broadcastEvent(Workspace.java:376)
	at org.eclipse.core.internal.resources.Resource.broadcastPreMoveEvent(Resource.java:1878)
	at org.eclipse.core.internal.resources.Resource.move(Resource.java:1493)
	at org.eclipse.ltk.core.refactoring.resource.RenameResourceChange.perform(RenameResourceChange.java:118)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:281)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.lambda$0(PerformChangeOperation.java:258)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2313)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2338)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:295)
	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.executeChange(UIPerformChangeOperation.java:94)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:219)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2313)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2338)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:89)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
!SESSION 2022-02-17 20:22:32.091 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-02-17 20:22:46.912
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-17 20:22:46.912
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5de6c7d7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69f55ea,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-17 20:22:50.871
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-17 20:22:50.872
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-17 20:22:50.898
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-18 09:17:12.522 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.core.resources 2 10035 2022-02-18 09:17:19.852
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2022-02-18 09:17:22.482
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-18 09:17:22.482
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5694f6a0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6e0dec27,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-18 09:17:26.530
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-18 09:17:26.531
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-18 09:17:26.559
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-21 22:01:35.568 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.core.resources 2 10035 2022-02-21 22:01:40.540
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2022-02-21 22:01:56.047
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-21 22:01:56.047
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3857c5d5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@237824b0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-21 22:02:00.870
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-21 22:02:00.871
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-21 22:02:00.898
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jst.jee 4 2 2022-02-21 23:27:39.260
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jst.jee".
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.emf.ecore.xmi.impl.XMLResourceImpl.setEncoding(String)" because "res" is null
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.createModelResource(JEE5ModelProvider.java:209)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.getModelResource(JEE5ModelProvider.java:190)
	at org.eclipse.jst.jee.model.internal.Web25ModelProvider.getModelObject(Web25ModelProvider.java:44)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.getModelObject(JEE5ModelProvider.java:233)
	at org.eclipse.jst.jee.model.internal.Web25MergedModelProvider.getXmlWebApp(Web25MergedModelProvider.java:59)
	at org.eclipse.jst.jee.model.internal.Web25MergedModelProvider.internalModelChanged(Web25MergedModelProvider.java:155)
	at org.eclipse.jst.jee.model.internal.Web25MergedModelProvider.xmlModelChanged(Web25MergedModelProvider.java:146)
	at org.eclipse.jst.jee.model.internal.common.AbstractMergedModelProvider$XmlModelListener.modelsChanged(AbstractMergedModelProvider.java:91)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider$NotifyRunner.run(JEE5ModelProvider.java:470)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.notifyListeners(JEE5ModelProvider.java:445)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.resourceChanged(JEE5ModelProvider.java:117)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider$ResourceAdapter.notifyChanged(JEE5ModelProvider.java:81)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.setModified(ResourceImpl.java:1867)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl$ContentsEList.modified(ResourceImpl.java:486)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl$ContentsEList.didRemove(ResourceImpl.java:447)
	at org.eclipse.emf.common.util.AbstractEList.didClear(AbstractEList.java:170)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl$ContentsEList.didClear(ResourceImpl.java:466)
	at org.eclipse.emf.common.util.BasicEList.clear(BasicEList.java:639)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.doClear(NotifyingListImpl.java:1158)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.clear(NotifyingListImpl.java:1085)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.doUnload(ResourceImpl.java:1699)
	at org.eclipse.emf.ecore.xmi.impl.XMLResourceImpl.doUnload(XMLResourceImpl.java:720)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.unload(ResourceImpl.java:1721)
	at org.eclipse.jem.internal.util.emf.workbench.ProjectResourceSetImpl.removeAndUnloadAllResources(ProjectResourceSetImpl.java:885)
	at org.eclipse.jem.internal.util.emf.workbench.ProjectResourceSetImpl.release(ProjectResourceSetImpl.java:866)
	at org.eclipse.wst.common.internal.emfworkbench.integration.ResourceSetWorkbenchEditSynchronizer.release(ResourceSetWorkbenchEditSynchronizer.java:222)
	at org.eclipse.jem.util.emf.workbench.ResourceSetWorkbenchSynchronizer.resourceChanged(ResourceSetWorkbenchSynchronizer.java:184)
	at org.eclipse.wst.common.internal.emfworkbench.integration.ResourceSetWorkbenchEditSynchronizer.resourceChanged(ResourceSetWorkbenchEditSynchronizer.java:137)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.handleEvent(NotificationManager.java:271)
	at org.eclipse.core.internal.resources.Workspace.broadcastEvent(Workspace.java:376)
	at org.eclipse.core.internal.resources.Resource.broadcastPreMoveEvent(Resource.java:1878)
	at org.eclipse.core.internal.resources.Resource.move(Resource.java:1493)
	at org.eclipse.ltk.core.refactoring.resource.RenameResourceChange.perform(RenameResourceChange.java:118)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:281)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.lambda$0(PerformChangeOperation.java:258)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2313)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2338)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:295)
	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.executeChange(UIPerformChangeOperation.java:94)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:219)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2313)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2338)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:89)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.jst.jee 4 0 2022-02-21 23:27:39.261
!MESSAGE Cannot invoke "org.eclipse.emf.ecore.xmi.impl.XMLResourceImpl.setEncoding(String)" because "res" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.emf.ecore.xmi.impl.XMLResourceImpl.setEncoding(String)" because "res" is null
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.createModelResource(JEE5ModelProvider.java:209)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.getModelResource(JEE5ModelProvider.java:190)
	at org.eclipse.jst.jee.model.internal.Web25ModelProvider.getModelObject(Web25ModelProvider.java:44)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.getModelObject(JEE5ModelProvider.java:233)
	at org.eclipse.jst.jee.model.internal.Web25MergedModelProvider.getXmlWebApp(Web25MergedModelProvider.java:59)
	at org.eclipse.jst.jee.model.internal.Web25MergedModelProvider.internalModelChanged(Web25MergedModelProvider.java:155)
	at org.eclipse.jst.jee.model.internal.Web25MergedModelProvider.xmlModelChanged(Web25MergedModelProvider.java:146)
	at org.eclipse.jst.jee.model.internal.common.AbstractMergedModelProvider$XmlModelListener.modelsChanged(AbstractMergedModelProvider.java:91)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider$NotifyRunner.run(JEE5ModelProvider.java:470)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.notifyListeners(JEE5ModelProvider.java:445)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider.resourceChanged(JEE5ModelProvider.java:117)
	at org.eclipse.jst.jee.model.internal.JEE5ModelProvider$ResourceAdapter.notifyChanged(JEE5ModelProvider.java:81)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.setModified(ResourceImpl.java:1867)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl$ContentsEList.modified(ResourceImpl.java:486)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl$ContentsEList.didRemove(ResourceImpl.java:447)
	at org.eclipse.emf.common.util.AbstractEList.didClear(AbstractEList.java:170)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl$ContentsEList.didClear(ResourceImpl.java:466)
	at org.eclipse.emf.common.util.BasicEList.clear(BasicEList.java:639)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.doClear(NotifyingListImpl.java:1158)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.clear(NotifyingListImpl.java:1085)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.doUnload(ResourceImpl.java:1699)
	at org.eclipse.emf.ecore.xmi.impl.XMLResourceImpl.doUnload(XMLResourceImpl.java:720)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.unload(ResourceImpl.java:1721)
	at org.eclipse.jem.internal.util.emf.workbench.ProjectResourceSetImpl.removeAndUnloadAllResources(ProjectResourceSetImpl.java:885)
	at org.eclipse.jem.internal.util.emf.workbench.ProjectResourceSetImpl.release(ProjectResourceSetImpl.java:866)
	at org.eclipse.wst.common.internal.emfworkbench.integration.ResourceSetWorkbenchEditSynchronizer.release(ResourceSetWorkbenchEditSynchronizer.java:222)
	at org.eclipse.jem.util.emf.workbench.ResourceSetWorkbenchSynchronizer.resourceChanged(ResourceSetWorkbenchSynchronizer.java:184)
	at org.eclipse.wst.common.internal.emfworkbench.integration.ResourceSetWorkbenchEditSynchronizer.resourceChanged(ResourceSetWorkbenchEditSynchronizer.java:137)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.handleEvent(NotificationManager.java:271)
	at org.eclipse.core.internal.resources.Workspace.broadcastEvent(Workspace.java:376)
	at org.eclipse.core.internal.resources.Resource.broadcastPreMoveEvent(Resource.java:1878)
	at org.eclipse.core.internal.resources.Resource.move(Resource.java:1493)
	at org.eclipse.ltk.core.refactoring.resource.RenameResourceChange.perform(RenameResourceChange.java:118)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:281)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.lambda$0(PerformChangeOperation.java:258)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2313)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2338)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:295)
	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.executeChange(UIPerformChangeOperation.java:94)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:219)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2313)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2338)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:89)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
!SESSION 2022-02-22 10:12:54.621 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-02-22 10:13:15.561
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-22 10:13:15.561
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4687fee7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a0fc665,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-22 10:13:19.951
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-22 10:13:19.952
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-22 10:13:19.988
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-23 11:33:57.136 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.core.resources 2 10035 2022-02-23 11:34:02.306
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2022-02-23 11:34:15.925
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-23 11:34:15.925
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5694f6a0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6e0dec27,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-23 11:34:20.478
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-23 11:34:20.479
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-23 11:34:20.508
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-23 12:11:08.340 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-02-23 12:11:13.970
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-23 12:11:13.970
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@52a8f789,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5345552f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-23 12:11:17.485
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-23 12:11:17.485
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-23 12:11:17.513
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-23 21:32:49.126 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.core.resources 2 10035 2022-02-23 21:32:54.100
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2022-02-23 21:32:55.970
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-23 21:32:55.971
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@22b4ad0c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@25af1dbf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-23 21:32:59.895
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-23 21:32:59.896
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-23 21:32:59.921
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-23 23:47:39.225 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-02-23 23:47:45.135
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-23 23:47:45.135
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@37f0fb02,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4687fee7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-23 23:47:48.897
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-23 23:47:48.898
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-23 23:47:48.929
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-24 09:10:38.762 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-02-24 09:11:01.738
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-24 09:11:01.738
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@207f7baa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1067bc4c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-24 09:11:07.582
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-24 09:11:07.584
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-24 09:11:07.629
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:45:44.240
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = ""
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:45:44.243
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:45:44.244
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:45:44.533
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = ""
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:45:44.534
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:45:44.534
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:05.088
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = ""
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:05.089
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:05.090
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:07.768
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = ""
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:07.768
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:07.769
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:07.851
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = ""
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:07.851
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:07.851
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:08.777
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UP"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:08.777
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:08.778
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:08.793
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPD"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:08.794
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:08.794
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:11.249
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE user"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:11.249
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:11.250
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:11.294
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE user"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:11.295
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:11.295
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:13.304
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo "
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:13.304
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:13.305
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:13.482
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo "
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:13.483
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:13.483
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:16.814
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET u"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:16.814
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:16.815
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:17.040
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET u"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:17.041
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:17.041
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:20.324
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:20.324
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:20.325
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:20.332
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:20.333
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:20.333
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:22.335
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?,"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:22.336
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:22.336
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:22.344
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, "
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:22.345
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:22.345
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:23.105
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, u"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:23.106
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:23.106
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:26.065
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, pw"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:26.065
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:26.066
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:26.851
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, pw"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:26.851
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:26.851
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:29.862
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:29.862
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:29.862
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:29.869
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:29.870
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:29.870
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:30.766
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:30.766
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:30.767
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:31.872
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw="
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:31.873
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:31.873
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:32.010
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw="
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:32.011
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:32.011
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:32.881
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:32.881
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:32.882
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:32.926
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:32.927
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:32.927
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:35.390
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:35.391
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:35.391
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:38.401
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, u"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:38.401
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:38.402
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:42.411
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail="
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:42.411
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:42.411
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:42.418
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail="
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:42.419
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:42.419
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:42.579
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail="
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:42.580
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:42.580
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:43.421
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail=?"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:43.422
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:43.422
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:43.510
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail=?"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:43.511
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:43.511
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:44.428
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail=? "
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:44.429
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:44.429
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:44.577
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail=? "
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:44.578
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:44.578
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:46.937
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail=? WHERE"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:46.938
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:46.938
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:47.129
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail=? WHERE"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:47.130
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:47.130
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:47.947
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail=? WHERE "
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:47.947
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:47.948
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:49.456
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail=? WHERE uid"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:49.457
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:49.457
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:50.965
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail=? WHERE uid = "
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:50.966
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:50.966
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:50.974
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail=? WHERE uid = "
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:50.975
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:50.975
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:51.974
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail=? WHERE uid = ?"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:46:51.975
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:46:51.975
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:51.982
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail=? WHERE uid = ?"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:51.984
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:51.984
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:46:56.547
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail=? WHERE uid = ?"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:46:56.548
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:46:56.549
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:47:04.290
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail=? WHERE uid = ?"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:47:04.291
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:47:04.291
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:47:26.524
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail=? WHERE uid=?"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-24 09:47:26.524
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-24 09:47:26.525
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-24 09:47:26.657
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.co.ict;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// DAO 클래스는 DB연동을 전담하여 처리합니다.
public class UserDAO {
	
	// DB접속에 필요한 변수들을 아래에 선언합니다.
	private String dbType = "com.mysql.cj.jdbc.Driver";
	private String dbUrl = "jdbc:mysql://localhost:3306/jdbcprac1";
	private String dbId = "root";
	private String dbPw = "mysql";

	// 성성자를 이용해 생성할 때 자동으로 Class.forName()을 실행하게 만듭니다.
	// 어떤 쿼리문을 실행하더라도
	public UserDAO() {
		try {
			Class.forName(dbType);
		
		}catch(Exception e) {
			e.printStackTrace();
		}
	}


      // user_list2.jsp의 코드 로직을 대체해보겠습니다.
	  // user_list2.jsp에서 전체 유저 목록을 필요로 하기 때문에
	  // 실행 결과로 List<UserVO>를 리턴해줘야 합니다.
	  // 역시 SELECT구문을 실행할때에는 리턴자료가 필요하고
	  // INSERT, DELETE, UPDATE구문을 실행할때는 리턴자료가 void입니다.
  public List<UserVO> getAllUserList(){


	  
	  
	  //login_update.jsp의 경우 로그인한 유저 한 명의 데이터만 DB에서 얻어옵니다.
	  // 따라서, 그 한 명의 유저 데이터만을 이용해 SELECT구문을 써야합니다.
	  // login_update.jsp 상단의 sId 변수에 들어있는 유저명을 이요해 유저 데이터를 얻어옵니다.
	
	  
	 // Connection, PreparedStatement, ResultSet을 선언합니다.
	  Connection con =null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	  // try블럭 진입 전에 ArrayList 선언
	  List<UserVO> userList = new ArrayList<>();
	  
	  try {
	  // Connection, PreparedStatement, ResultSet을 선언합니다.
	  con = DriverManager.getConnection(dbUrl,dbId, dbPw);
  	//3. SELECT * FROM userinfo
  	 String sql = "SELECT * FROM userinfo";
  	 
  	 pstmt = con.prepareStatement(sql);
  	
  	 rs = pstmt.executeQuery(); 
	  
	  // UserVO ArrayList에 rs에 든 모든 자료를 저장해주세요.
  	 
  	 while(rs.next()){
		 
		 String uName = rs.getString("uname");
		 String uId = rs.getString("uid");
		 String uPw = rs.getString("upw");
		 String uEmail = rs.getString("uemail");
		 
		 UserVO userDate = new UserVO(uName, uId, uPw, uEmail);
		 userList.add(userDate);
	 }
            	
  	 
	  }catch(Exception e) {
		  e.printStackTrace();
	  }finally {
	   
		  try {
	    	 
	    	 con.close();
		     pstmt.close();
		     rs.close();
		  } catch(SQLException se) {
			  se.printStackTrace();
		  }
		 
  
	  }
	  return userList;
  }



public UserVO getUserDate(String sId){
	  // 접속로직은 getAllUserList()와 큰 차이가 없고 쿼리문만 좀 다릅니다.
	  
	  // 1. Connection, PreparedStatemtnt,ResultSet 변수 선언만 해주세요.
	  // UserVO 변수 선언
	   // try블럭 외부에서 써야하는 (Connection,PreparedStatment, ResultSet은 finally블럭에서도 사용)
	// (UserVO는 return구문에서 사용)것들을 try진입 전에 먼저 선언합니다.
	   
	   Connection con = null;
	   PreparedStatement pstmt = null;
	   ResultSet rs = null;
	   UserVO user= null;
	  
	  // 2. try블럭 내부에서 DB연결을 해주세요. 필요한 URL, ID, PW는 상단에 멤버변수로 이미 존해합니다.
	
	   try {
		     Class.forName(dbType);
		    con = DriverManager.getConnection(dbUrl, dbId, dbPw);
		     
		   
		 // 3. 쿼리문을 날려서 rs에 DB에서 가져온 정보를 받아주세요.
		    String sql = "SELECT * FROM userinfo WHERE uid=?";
		   pstmt = con.prepareStatement(sql);
		   pstmt.setString(1, sId); 
		   
		   rs=pstmt.executeQuery();
		    
		// 4. UserVO 변수를 선언해주시고, rs에 저장된 데이터를 UserVO에 담습니다.
		   
		  
		    if(rs.next()) {
		    
		    String uName = rs.getString("uname");
		    String uId = rs.getString("uid");
		    String uPw = rs.getString("upw");
		    String uEmail = rs.getString("uemail");
		    user = new UserVO(uName, uId, uPw, uEmail);
			
			
		    }
	   
	   
	   }catch(Exception e) {
		   e.printStackTrace();
	   }finally {
      
		// 5. catch, finally 블럭을 작성해주시고 finally에서 자원회수까지 마쳐주세요.
		   try {
        	   con.close();
            	 pstmt.close();
            	 rs.close();  
          }catch(Exception e) {
        	  e.printStackTrace();
          }
                
		
	   }
	   
	  
	 return user;//DB에서 UserVO에 데이터를 받아주신 다음 null대신 받아온 데이터를 리턴하세요.
	 }

     // updateCheck에 필요한 userUpdate메서드를 아래에 정의해주세요.
     // UPDATE구문을 실행하기 때문에 리턴 자료가 필요없고
     // update_check.jsp에 있는 쿼리문을 실행하기 위해
     // id, pw, name, email정보를 모두 받아옵니다.

  public userVO userUpdate(String sId) {
	  
	  try {
		  
		  Class.forName(dbType);
		  Connection con = DriverManager.getConnection(dbUrl,dbId,dbPw);
		  String sql = "UPDATE userinfo SET uname=?, upw=?, uemail=? WHERE uid=?"
		  
		  catch(Exception e) {
			e.printStackTrace();  
		  }finally {
			  
		  }
	  }
	  
  }


} 
	
	 
        
	
	 
	
	
	 
	  

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-24 09:47:26.658
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-24 09:47:26.658
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3246)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-02-24 11:20:56.846 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-02-24 11:21:02.234
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-24 11:21:02.234
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@207f7baa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1067bc4c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-24 11:21:06.408
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-24 11:21:06.409
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-24 11:21:06.434
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.wst.xml.core 4 4 2022-02-24 20:44:33.357
!MESSAGE IStructuredDocumentRegion management failed.
!STACK 0
org.eclipse.wst.xml.core.internal.document.StructuredDocumentRegionManagementException: IStructuredDocumentRegion management failed.
	at org.eclipse.wst.xml.core.internal.document.XMLModelParser.removeStructuredDocumentRegion(XMLModelParser.java:2267)
	at org.eclipse.wst.xml.core.internal.document.XMLModelParser.changeStructuredDocumentRegion(XMLModelParser.java:548)
	at org.eclipse.wst.xml.core.internal.document.XMLModelParser.changeTagName(XMLModelParser.java:580)
	at org.eclipse.wst.xml.core.internal.document.XMLModelParser.changeRegion(XMLModelParser.java:349)
	at org.eclipse.wst.xml.core.internal.document.DOMModelImpl.regionChanged(DOMModelImpl.java:801)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument._fireEvent(BasicStructuredDocument.java:544)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.fireStructuredDocumentEvent(BasicStructuredDocument.java:1182)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.internalReplaceText(BasicStructuredDocument.java:1966)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.replaceText(BasicStructuredDocument.java:2425)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.replaceText(BasicStructuredDocument.java:2410)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.access$2(JobSafeStructuredDocument.java:1)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument$3.run(JobSafeStructuredDocument.java:143)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.wst.sse.ui.EditorExecutionContext.execute(EditorExecutionContext.java:150)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.replaceText(JobSafeStructuredDocument.java:146)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.replace(BasicStructuredDocument.java:2370)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.access$0(JobSafeStructuredDocument.java:1)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument$1.run(JobSafeStructuredDocument.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.wst.sse.ui.EditorExecutionContext.execute(EditorExecutionContext.java:150)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.replace(JobSafeStructuredDocument.java:108)
	at org.eclipse.jface.text.projection.ProjectionTextStore.replace(ProjectionTextStore.java:106)
	at org.eclipse.jface.text.AbstractDocument.replace(AbstractDocument.java:1093)
	at org.eclipse.jface.text.AbstractDocument.replace(AbstractDocument.java:1118)
	at org.eclipse.jface.text.projection.ProjectionDocument.replace(ProjectionDocument.java:627)
	at org.eclipse.jface.text.DefaultDocumentAdapter.replaceTextRange(DefaultDocumentAdapter.java:223)
	at org.eclipse.swt.custom.StyledText.modifyContent(StyledText.java:7601)
	at org.eclipse.swt.custom.StyledText.sendKeyEvent(StyledText.java:8501)
	at org.eclipse.swt.custom.StyledText.doBackspace(StyledText.java:2340)
	at org.eclipse.swt.custom.StyledText.invokeAction(StyledText.java:7390)
	at org.eclipse.swt.custom.StyledText.handleKey(StyledText.java:6226)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6253)
	at org.eclipse.swt.custom.StyledText.lambda$28(StyledText.java:5932)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4958)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2022-02-25 09:03:06.840 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-02-25 09:03:33.510
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-25 09:03:33.510
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5de6c7d7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69f55ea,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-25 09:03:38.812
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-25 09:03:38.813
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-25 09:03:38.849
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.wst.xml.core 4 4 2022-02-25 11:26:57.093
!MESSAGE IStructuredDocumentRegion management failed.
!STACK 0
org.eclipse.wst.xml.core.internal.document.StructuredDocumentRegionManagementException: IStructuredDocumentRegion management failed.
	at org.eclipse.wst.xml.core.internal.document.XMLModelParser.removeStructuredDocumentRegion(XMLModelParser.java:2224)
	at org.eclipse.wst.xml.core.internal.document.XMLModelParser.replaceStructuredDocumentRegions(XMLModelParser.java:2341)
	at org.eclipse.wst.xml.core.internal.document.DOMModelImpl.nodesReplaced(DOMModelImpl.java:742)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument._fireEvent(BasicStructuredDocument.java:602)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.fireStructuredDocumentEvent(BasicStructuredDocument.java:1200)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.internalReplaceText(BasicStructuredDocument.java:1981)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.replaceText(BasicStructuredDocument.java:2425)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.replaceText(BasicStructuredDocument.java:2410)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.access$2(JobSafeStructuredDocument.java:1)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument$3.run(JobSafeStructuredDocument.java:143)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.wst.sse.ui.EditorExecutionContext.execute(EditorExecutionContext.java:150)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.replaceText(JobSafeStructuredDocument.java:146)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.replace(BasicStructuredDocument.java:2370)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.access$0(JobSafeStructuredDocument.java:1)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument$1.run(JobSafeStructuredDocument.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.wst.sse.ui.EditorExecutionContext.execute(EditorExecutionContext.java:150)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.replace(JobSafeStructuredDocument.java:108)
	at org.eclipse.jface.text.projection.ProjectionTextStore.replace(ProjectionTextStore.java:106)
	at org.eclipse.jface.text.AbstractDocument.replace(AbstractDocument.java:1093)
	at org.eclipse.jface.text.AbstractDocument.replace(AbstractDocument.java:1118)
	at org.eclipse.jface.text.projection.ProjectionDocument.replace(ProjectionDocument.java:627)
	at org.eclipse.jface.text.DefaultDocumentAdapter.replaceTextRange(DefaultDocumentAdapter.java:223)
	at org.eclipse.swt.custom.StyledText.modifyContent(StyledText.java:7601)
	at org.eclipse.swt.custom.StyledText.sendKeyEvent(StyledText.java:8501)
	at org.eclipse.swt.custom.StyledText.doContent(StyledText.java:2540)
	at org.eclipse.swt.custom.StyledText.handleKey(StyledText.java:6222)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6253)
	at org.eclipse.swt.custom.StyledText.lambda$28(StyledText.java:5932)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4958)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2022-02-26 00:05:35.268
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:683)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:274)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:287)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:265)
	at org.eclipse.wst.xml.ui.internal.ImageDescriptorRegistry.getImage(ImageDescriptorRegistry.java:36)
	at org.eclipse.wst.xml.ui.internal.tabletree.XMLMultiPageEditorPart.createPages(XMLMultiPageEditorPart.java:795)
	at org.eclipse.ui.part.MultiPageEditorPart.createPartControl(MultiPageEditorPart.java:333)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:994)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:104)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4770)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:228)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.internal.workbench.ModelServiceImpl.showElementInWindow(ModelServiceImpl.java:660)
	at org.eclipse.e4.ui.internal.workbench.ModelServiceImpl.bringToTop(ModelServiceImpl.java:624)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.delegateBringToTop(PartServiceImpl.java:786)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.bringToTop(PartServiceImpl.java:400)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.showPart(PartServiceImpl.java:1260)
	at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:3195)
	at org.eclipse.ui.internal.WorkbenchPage.lambda$9(WorkbenchPage.java:3100)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3098)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3068)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3059)
	at org.eclipse.ui.ide.IDE.openEditor(IDE.java:569)
	at org.eclipse.ui.ide.IDE.openEditor(IDE.java:524)
	at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:367)
	at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:172)
	at org.eclipse.jdt.ui.actions.OpenAction.run(OpenAction.java:288)
	at org.eclipse.jdt.ui.actions.OpenAction.run(OpenAction.java:254)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:274)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:252)
	at org.eclipse.jdt.internal.ui.navigator.OpenAndExpand.run(OpenAndExpand.java:53)
	at org.eclipse.ui.actions.RetargetAction.run(RetargetAction.java:215)
	at org.eclipse.ui.navigator.CommonNavigatorManager$1.open(CommonNavigatorManager.java:183)
	at org.eclipse.ui.OpenAndLinkWithEditorHelper$InternalListener.open(OpenAndLinkWithEditorHelper.java:48)
	at org.eclipse.jface.viewers.StructuredViewer$2.run(StructuredViewer.java:800)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.StructuredViewer.fireOpen(StructuredViewer.java:797)
	at org.eclipse.jface.viewers.StructuredViewer.handleOpen(StructuredViewer.java:1116)
	at org.eclipse.ui.navigator.CommonViewer.handleOpen(CommonViewer.java:454)
	at org.eclipse.jface.util.OpenStrategy.fireOpenEvent(OpenStrategy.java:275)
	at org.eclipse.jface.util.OpenStrategy$1.handleEvent(OpenStrategy.java:310)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4054)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2022-02-26 00:05:35.288
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:683)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:274)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:287)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:265)
	at org.eclipse.wst.xml.ui.internal.ImageDescriptorRegistry.getImage(ImageDescriptorRegistry.java:36)
	at org.eclipse.wst.xml.ui.internal.tabletree.XMLMultiPageEditorPart.createPages(XMLMultiPageEditorPart.java:794)
	at org.eclipse.ui.part.MultiPageEditorPart.createPartControl(MultiPageEditorPart.java:333)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:994)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:104)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4770)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:228)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.internal.workbench.ModelServiceImpl.showElementInWindow(ModelServiceImpl.java:660)
	at org.eclipse.e4.ui.internal.workbench.ModelServiceImpl.bringToTop(ModelServiceImpl.java:624)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.delegateBringToTop(PartServiceImpl.java:786)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.bringToTop(PartServiceImpl.java:400)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.showPart(PartServiceImpl.java:1260)
	at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:3195)
	at org.eclipse.ui.internal.WorkbenchPage.lambda$9(WorkbenchPage.java:3100)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3098)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3068)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3059)
	at org.eclipse.ui.ide.IDE.openEditor(IDE.java:569)
	at org.eclipse.ui.ide.IDE.openEditor(IDE.java:524)
	at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:367)
	at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:172)
	at org.eclipse.jdt.ui.actions.OpenAction.run(OpenAction.java:288)
	at org.eclipse.jdt.ui.actions.OpenAction.run(OpenAction.java:254)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:274)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:252)
	at org.eclipse.jdt.internal.ui.navigator.OpenAndExpand.run(OpenAndExpand.java:53)
	at org.eclipse.ui.actions.RetargetAction.run(RetargetAction.java:215)
	at org.eclipse.ui.navigator.CommonNavigatorManager$1.open(CommonNavigatorManager.java:183)
	at org.eclipse.ui.OpenAndLinkWithEditorHelper$InternalListener.open(OpenAndLinkWithEditorHelper.java:48)
	at org.eclipse.jface.viewers.StructuredViewer$2.run(StructuredViewer.java:800)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.StructuredViewer.fireOpen(StructuredViewer.java:797)
	at org.eclipse.jface.viewers.StructuredViewer.handleOpen(StructuredViewer.java:1116)
	at org.eclipse.ui.navigator.CommonViewer.handleOpen(CommonViewer.java:454)
	at org.eclipse.jface.util.OpenStrategy.fireOpenEvent(OpenStrategy.java:275)
	at org.eclipse.jface.util.OpenStrategy$1.handleEvent(OpenStrategy.java:310)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4054)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2022-02-26 10:20:06.531 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-02-26 10:20:28.195
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-26 10:20:28.195
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@207f7baa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1067bc4c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-26 10:20:32.577
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-26 10:20:32.578
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-26 10:20:32.604
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.lsp4e 1 0 2022-02-26 10:44:31.609
!MESSAGE [Info]	ESLint server running in node v14.15.4

!ENTRY org.eclipse.lsp4e 4 0 2022-02-26 10:44:39.129
!MESSAGE [Error]	[tsserver] npm notice created a lockfile as package-lock.json. You should commit this file.

!SESSION 2022-02-26 10:45:08.945 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-02-26 10:45:18.657
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-26 10:45:18.657
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1067bc4c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69ee0861,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.lsp4e 1 0 2022-02-26 10:45:21.937
!MESSAGE [Info]	ESLint server running in node v14.15.4

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-26 10:45:23.066
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-26 10:45:23.067
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-26 10:45:23.113
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-26 21:09:15.030 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-02-26 21:09:36.830
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-26 21:09:36.830
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69ee0861,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5de6c7d7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-26 21:09:41.190
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-26 21:09:41.191
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-26 21:09:41.227
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-27 10:58:32.178 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-02-27 10:58:59.311
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-27 10:58:59.311
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5bbb0a25,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@244c0fbe,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-27 10:59:04.389
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-27 10:59:04.389
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-27 10:59:04.415
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-27 21:22:16.079 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-02-27 21:22:36.528
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-27 21:22:36.528
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@363d29dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19b4dd60,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-27 21:22:41.415
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-27 21:22:41.418
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-27 21:22:41.483
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-28 08:56:45.847 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-02-28 08:59:48.937
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-28 08:59:48.937
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@213bd66a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5692863,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-28 08:59:53.424
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-02-28 08:59:53.426
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-02-28 08:59:53.470
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-02 09:00:24.697 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-03-02 09:00:46.860
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-02 09:00:46.860
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1188e08b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@12e13abd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-03-02 09:00:50.500
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-03-02 09:00:50.501
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-03-02 09:00:52.078
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.wst.sse.ui 2 2 2022-03-02 21:01:17.367
!MESSAGE StructuredTextEditor being used without StructuredDocument

!ENTRY org.eclipse.wst.sse.ui 2 2 2022-03-02 21:01:17.368
!MESSAGE          Input Name: logout_jsp

!ENTRY org.eclipse.wst.sse.ui 2 2 2022-03-02 21:01:17.368
!MESSAGE         Unexpected IDocumentProvider implementation: org.eclipse.ui.editors.text.TextFileDocumentProvider

!ENTRY org.eclipse.wst.sse.ui 2 2 2022-03-02 21:01:17.368
!MESSAGE         Unexpected IDocument implementation: org.eclipse.core.internal.filebuffers.SynchronizableDocument

!ENTRY org.eclipse.core.filebuffers 4 2 2022-03-02 21:01:17.370
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.core.filebuffers".
!STACK 0
java.lang.ClassCastException: class org.eclipse.core.internal.filebuffers.SynchronizableDocument cannot be cast to class org.eclipse.wst.sse.core.internal.provisional.text.IStructuredDocument (org.eclipse.core.internal.filebuffers.SynchronizableDocument is in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @338f96f5; org.eclipse.wst.sse.core.internal.provisional.text.IStructuredDocument is in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @27d1b432)
	at org.eclipse.wst.sse.ui.internal.StructuredTextViewer.configure(StructuredTextViewer.java:355)
	at org.eclipse.wst.sse.ui.StructuredTextEditor.updateSourceViewerConfiguration(StructuredTextEditor.java:3670)
	at org.eclipse.wst.sse.ui.StructuredTextEditor.update(StructuredTextEditor.java:3276)
	at org.eclipse.wst.sse.ui.StructuredTextEditor.setModel(StructuredTextEditor.java:3140)
	at org.eclipse.wst.sse.ui.StructuredTextEditor.doSetInput(StructuredTextEditor.java:2075)
	at org.eclipse.ui.texteditor.AbstractTextEditor.setInputWithNotify(AbstractTextEditor.java:4244)
	at org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:4264)
	at org.eclipse.ui.texteditor.AbstractTextEditor$ElementStateListener$1.run(AbstractTextEditor.java:527)
	at org.eclipse.ui.texteditor.AbstractTextEditor$ElementStateListener.execute(AbstractTextEditor.java:588)
	at org.eclipse.ui.texteditor.AbstractTextEditor$ElementStateListener.elementMoved(AbstractTextEditor.java:555)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider$FileBufferListener.underlyingFileMoved(TextFileDocumentProvider.java:335)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager$6.run(TextFileBufferManager.java:709)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.fireUnderlyingFileMoved(TextFileBufferManager.java:706)
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.handleFileMoved(ResourceFileBuffer.java:422)
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer$FileSynchronizer$3.execute(ResourceFileBuffer.java:163)
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer$SafeFileChange.run(ResourceFileBuffer.java:86)
	at org.eclipse.ui.internal.editors.text.UISynchronizationContext.run(UISynchronizationContext.java:35)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.execute(TextFileBufferManager.java:592)
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer$FileSynchronizer.resourceChanged(ResourceFileBuffer.java:184)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastPostChange(Workspace.java:381)
	at org.eclipse.core.internal.resources.Workspace.endOperation(Workspace.java:1503)
	at org.eclipse.core.internal.resources.Resource.move(Resource.java:1524)
	at org.eclipse.ltk.core.refactoring.resource.RenameResourceChange.perform(RenameResourceChange.java:118)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:281)
	at org.eclipse.ltk.internal.ui.refactoring.actions.RenameResourceHandler.performRename(RenameResourceHandler.java:110)
	at org.eclipse.ltk.internal.ui.refactoring.actions.RenameResourceHandler.execute(RenameResourceHandler.java:58)
	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:283)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor51.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.executeCommandInContext(LegacyHandlerService.java:440)
	at org.eclipse.ui.internal.ide.actions.LTKLauncher.runCommand(LTKLauncher.java:140)
	at org.eclipse.ui.internal.ide.actions.LTKLauncher.renameResource(LTKLauncher.java:86)
	at org.eclipse.ui.actions.RenameResourceAction.lambda$5(RenameResourceAction.java:548)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2022-03-03 09:06:18.654 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-03-03 09:06:38.535
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-03 09:06:38.535
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a0fc665,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@207f7baa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-03-03 09:06:43.154
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-03-03 09:06:43.155
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-03-03 09:06:43.185
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-03 21:59:40.316 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-03-03 21:59:49.008
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-03 21:59:49.008
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5bbb0a25,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@244c0fbe,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-03-03 21:59:51.664
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-03-03 21:59:51.665
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-03-03 21:59:51.698
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-04 00:20:23.528 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-03-04 00:20:31.832
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-04 00:20:31.832
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69ee0861,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5de6c7d7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-03-04 00:20:35.586
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-03-04 00:20:35.588
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-03-04 00:20:35.642
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-04 09:00:51.776 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-03-04 09:01:12.246
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-04 09:01:12.246
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b370ca9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3203a4ae,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-03-04 09:01:16.340
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-03-04 09:01:16.341
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-03-04 09:01:16.362
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\muhwan'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2022-03-04 14:07:29.187
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable (org.eclipse.jst.jsp.core.internal.java.jspel.TokenMgrError: Lexical error at line 1, column 2.  Encountered: "{" (123), after : "")
	at org.eclipse.swt.SWT.error(SWT.java:4893)
	at org.eclipse.swt.SWT.error(SWT.java:4808)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:188)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: org.eclipse.jst.jsp.core.internal.java.jspel.TokenMgrError: Lexical error at line 1, column 2.  Encountered: "{" (123), after : ""
	at org.eclipse.jst.jsp.core.internal.java.jspel.JSPELParserTokenManager.getNextToken(JSPELParserTokenManager.java:847)
	at org.eclipse.jst.jsp.ui.internal.contentassist.JSPELCompletionProposalComputer.getPrefix(JSPELCompletionProposalComputer.java:112)
	at org.eclipse.jst.jsp.ui.internal.contentassist.JSPELCompletionProposalComputer.computeCompletionProposals(JSPELCompletionProposalComputer.java:80)
	at org.eclipse.wst.sse.ui.internal.contentassist.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:290)
	at org.eclipse.wst.sse.ui.internal.contentassist.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:292)
	at org.eclipse.wst.sse.ui.contentassist.StructuredContentAssistProcessor.collectProposals(StructuredContentAssistProcessor.java:486)
	at org.eclipse.wst.sse.ui.contentassist.StructuredContentAssistProcessor.computeCompletionProposals(StructuredContentAssistProcessor.java:257)
	at org.eclipse.wst.sse.ui.internal.contentassist.CompoundContentAssistProcessor.computeCompletionProposals(CompoundContentAssistProcessor.java:129)
	at org.eclipse.jface.text.contentassist.ContentAssistant$2.lambda$0(ContentAssistant.java:2022)
	at java.base/java.util.Collections$SingletonSet.forEach(Collections.java:4872)
	at org.eclipse.jface.text.contentassist.ContentAssistant$2.run(ContentAssistant.java:2021)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:2018)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:577)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.lambda$0(CompletionProposalPopup.java:507)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:502)
	at org.eclipse.jface.text.contentassist.ContentAssistant$AutoAssistListener.lambda$0(ContentAssistant.java:373)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	... 23 more
